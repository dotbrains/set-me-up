#!/bin/bash

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Create data URI from a file.

datauri() {

    local mimeType=""

    if [ -f "$1" ]; then
        mimeType=$(file -b --mime-type "$1")
        #                └─ do not prepend the FILE to the output

        if [[ $mimeType == text/* ]]; then
            mimeType="$mimeType;charset=utf-8"
        fi

        printf "data:%s;base64,%s" \
                    "$mimeType" \
                    "$(openssl base64 -in "$1" | tr -d "\n")"
    else
        printf "%s is not a file.\n" "$1"
    fi

}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Delete files that match a certain pattern from the current directory.

delete_files() {
    local q="${1:-*.DS_Store}"
    find . -type f -name "$q" -ls -delete
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Get gzip information (gzipped file size + reduction size).

gz() {

    declare -i GZIPPED_SIZE=0
    declare -i ORIGINAL_SIZE=0

    if [ -f "$1" ]; then
        if [ -s "$1" ]; then

            ORIGINAL_SIZE=$( wc -c < "$1" )
            printf "\n original size:   %12s\n" "$(hrfs "$ORIGINAL_SIZE")"

            GZIPPED_SIZE=$( gzip -c "$1" | wc -c )
            printf " gzipped size:    %12s\n" "$(hrfs "$GZIPPED_SIZE")"

            printf " ─────────────────────────────\n"
            printf " reduction:       %12s [%s%%]\n\n" \
                        "$( hrfs $((ORIGINAL_SIZE - GZIPPED_SIZE)) )" \
                        "$( printf "%s" "$ORIGINAL_SIZE $GZIPPED_SIZE" | \
                            awk '{ printf "%.1f", 100 - $2 * 100 / $1 }' | \
                            sed -e "s/0*$//;s/\.$//" )"
                            #              └─ remove tailing zeros

        else
            printf "\"%s\" is empty.\n" "$1"
        fi
    else
        printf "\"%s\" is not a file.\n" "$1"
    fi

}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Human readable file size
# (because `du -h` doesn't cut it for me).

hrfs() {

    printf "%s" "$1" |
    awk '{
            i = 1;
            split("B KB MB GB TB PB EB ZB YB WTFB", v);
            value = $1;

            # confirm that the input is a number
            if ( value + .0 == value ) {

                while ( value >= 1024 ) {
                    value/=1024;
                    i++;
                }

                if ( value == int(value) ) {
                    printf "%d %s", value, v[i]
                } else {
                    printf "%.1f %s", value, v[i]
                }

            }
        }' |
    sed -e ":l" \
        -e "s/\([0-9]\)\([0-9]\{3\}\)/\1,\2/; t l"
    #    └─ add thousands separator
    #       (changes "1023.2 KB" to "1,023.2 KB")
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Create new directories and enter the first one.

mkd() {
    if [ -n "$*" ]; then

        mkdir -p "$@"
        #      └─ make parent directories if needed

        cd "$@" \
            || exit 1

    fi
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Search history.

qh() {
    #           ┌─ enable colors for pipe
    #           │  ("--color=auto" enables colors only if
    #           │  the output is in the terminal)
    grep --color=always "$*" "$HISTFILE" |       less -RX
    # display ANSI color escape sequences in raw form ─┘│
    #       don't clear the screen after quitting less ─┘
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Search for text within the current directory.

qt() {
    grep -ir --color=always "$*" --exclude-dir=".git" --exclude-dir="node_modules" . | less -RX
    #     │└─ search all files under each directory, recursively
    #     └─ ignore case
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# extract any type of compressed file
function extract {
    echo Extracting "$1" ...
    if [ -f "$1" ] ; then
        case "$1" in
            *.tar.bz2)   tar xjf "$1"  ;;
            *.tar.gz)    tar xzf "$1"  ;;
            *.bz2)       bunzip2 "$1"  ;;
            *.rar)       rar x "$1"    ;;
            *.gz)        gunzip "$1"   ;;
            *.tar)       tar xf "$1"  ;;
            *.tbz2)      tar xjf "$1"  ;;
            *.tgz)       tar xzf "$1"  ;;
            *.zip)       unzip "$1"   ;;
            *.Z)         uncompress "$1"  ;;
            *.7z)        7z x "$1"  ;;
            *)        echo "'$1' cannot be extracted via extract()" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# check if APT package is installed
function is_apt_pkg_installed {
    if dpkg -s "$1" &> /dev/null; then
         print_success "($1) is installed"
    else
        print_error "($1)" "is not installed."
    fi
}

# check if pip package is installed
function is_pip_pkg_installed {
    if [[ "pip list --format legacy | grep $1 > /dev/null 2>&1" =~ "0" ]]; then
        print_success "($1) is installed"
    else
        print_error "($1)" "is not installed."
    fi
}

# check if brew package is installed
function is_brew_pkg_installed {
    if brew list "$1" &> /dev/null; then
        print_success "($1) is installed"
    else
        print_error "($1)" "is not installed."
    fi
}

# check if npm package is installed
function is_npm_pkg_installed {
    if npm list --depth 1 --global "$1" > /dev/null 2>&1; then
            print_success "($1) is installed"
    else
        print_error "($1)" "is not installed."
    fi
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# check if a certain process is running
function is_running {
    declare -r PROCESS="$1"

    if pgrep -f "$PROCESS" > /dev/null; then
        print_success "($PROCESS) is running"
    else
        print_error "($PROCESS)" "is not running."
    fi
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# ghf - [G]rep [H]istory [F]or top ten commands and execute one
# usage:
#  Most frequent command in recent history
#   ghf
#  Most frequent instances of {command} in all history
#   ghf {command}
#  Execute {command-number} after a call to ghf
#   !! {command-number}
function latest-history { history | tail -n 50 ; }
function grepped-history { history | grep "$1" ; }
function chop-first-column { awk '{for (i=2; i<NF; i++) printf $i " "; print $NF}' ; }
function add-line-numbers { awk '{print NR " " $0}' ; }
function top-ten { sort | uniq -c | sort -r | head -n 10 ; }
function unique-history { chop-first-column | top-ten | chop-first-column | add-line-numbers ; }
function ghf {
  if [ $# -eq 0 ]; then latest-history | unique-history; fi
  if [ $# -eq 1 ]; then grepped-history "$1" | unique-history; fi
  if [ $# -eq 2 ]; then
    grepped-history "$1" | unique-history | grep ^"$2" | chop-first-column;
  fi
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# piknik - Copy/paste anything over the network!
# see: https://github.com/jedisct1/piknik#suggested-shell-aliases

# pko <content> : copy <content> to the clipboard
pko() {
    echo "$*" | piknik -copy
}

# pkf <file> : copy the content of <file> to the clipboard
pkf() {
    piknik -copy < $1
}

# pkfr [<dir>] : send a whole directory to the clipboard, as a tar archive
pkfr() {
    tar czpvf - ${1:-.} | piknik -copy
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# transfer.sh - Easy file sharing from the command line.
# see: https://transfer.sh/

transfer() {
    if [ $# -eq 0 ]; then
        echo -e "No arguments specified. Usage:\necho transfer /tmp/test.md\ncat /tmp/test.md | transfer test.md";
        return 1;
    fi

    tmpfile=$( mktemp -t transferXXX );

    if tty -s; then
        basefile=$(basename "$1" | sed -e 's/[^a-zA-Z0-9._-]/-/g');
        curl --progress-bar --upload-file "$1" "https://transfer.sh/$basefile" >> $tmpfile;
    else
        curl --progress-bar --upload-file "-" "https://transfer.sh/$1" >> $tmpfile ;
    fi;

    cat $tmpfile;

    rm -f $tmpfile;

}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Vim functions

# Bash: Kill Vim when “Vim: Warning: Output not to a terminal”
# see: https://stackoverflow.com/a/46432233/5290011
vim() {
  [ -t 1 ] && \
    command vim "$@"
}
